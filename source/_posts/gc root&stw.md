title: 根节点和stw
tags: [java]
categories:
  - 编程语言
date: 2021-07-30 20:32:12
---
*  gc roots 有哪些？
1. 全局引用（静态变量或者常量的引用）
2. 执行上下文（局部变量表或者本地方法栈的变量表）
3. 跨代引用的对象，老年代对新生代的引用，记录在RSET中。
* 什么是stw（stop the world）
stw指的是停顿所有的用户线程，然后进行进行可达性分析。
* 什么情况下会出现stw
1. 枚举根节点时 必须stw
2. 整理内存碎片时 必须进行stw，也就是标记-整理算法必须stw
* 可达性分析包含那几部分，哪些部分必须stw。
可达性分析可以分为枚举根节点和查找引用链两个步骤。
枚举根节点是可达性分析准确性的基础,枚举根节点必须准确，所以必须stw。
查找引用链是耗时最长的操作，但是可以和用户线程并发执行，不需要stw。
* rset是什么？
rememberset 是一种用于记录从非收集区到收集区的指针集合的数据结构。
* 卡表、卡页和remenberset的区别和联系。
1. rset记录了非收集区到收集区的指针集合，也就是非收集区到收集区的引用关系。但是具体实现rset是依靠卡表。
2. 一块内存可以分成若干个卡页，每一个卡页是否存在跨代引用，使用卡表来记录。如果存在跨代引用那么就是dirty。如图所示：
![卡表和卡页对应关系](http://assets.processon.com/chart_image/61c4bb1c1e085364150a2a38.png)
垃圾回收时，只要筛选出卡表中 dirty的元素 即可获取到哪些卡页包含跨代引用，把这些卡页放到gc roots 中进行扫描。
* 卡表元素如何维护呢？何时变dirty，谁来把他们变dirty？
* 什么是伪共享，卡表是如何解决伪共享问题？
cpu的内存是以缓冲行为单位进行传输的，如果缓存行中多个数据频繁修改，会出现大量的缓冲回写，无效化和同步操作，导致效率变低。所以建议书写的代码具有局部性原理。
卡表如果每次写操作都更新，那么就会面临伪共享问题。如果在每次将卡表变脏前，先检查卡表是否为脏，只有不为脏的卡表才更新，可以降低伪共享的问题。
